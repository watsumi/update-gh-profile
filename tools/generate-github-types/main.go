package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

// TypeDefinition å‹å®šç¾©ã®æƒ…å ±
type TypeDefinition struct {
	Name        string
	Description string
	Fields      []FieldDefinition
}

// FieldDefinition ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ã®æƒ…å ±
type FieldDefinition struct {
	Name        string
	Type        string
	Description string
	Required    bool
}

// æŠ½å‡ºã™ã‚‹å‹ã®ãƒªã‚¹ãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦è¿½åŠ ï¼‰
var typesToExtract = []string{
	"User",
	"Repository",
	"RepositoryOwner",
	"Language",
	"Commit",
	"CommitHistory",
	"PageInfo",
	"ContributionsCollection",
	"CommitContributionsByRepository",
	"RepositoryConnection",
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <schema.docs.graphql> [output-dir]\n", os.Args[0])
		os.Exit(1)
	}

	schemaPath := os.Args[1]
	outputDir := "internal/graphql/generated"
	if len(os.Args) > 2 {
		outputDir = os.Args[2]
	}

	fmt.Printf("ğŸ“– ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­: %s\n", schemaPath)
	types, err := parseSchema(schemaPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ã‚¨ãƒ©ãƒ¼: ã‚¹ã‚­ãƒ¼ãƒã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("âœ… %då€‹ã®å‹å®šç¾©ã‚’æŠ½å‡ºã—ã¾ã—ãŸ\n", len(types))

	// å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "ã‚¨ãƒ©ãƒ¼: å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: %v\n", err)
		os.Exit(1)
	}

	// å‹å®šç¾©ã‚’ç”Ÿæˆ
	outputPath := filepath.Join(outputDir, "types.go")
	fmt.Printf("ğŸ“ å‹å®šç¾©ã‚’ç”Ÿæˆä¸­: %s\n", outputPath)
	if err := generateTypes(outputPath, types); err != nil {
		fmt.Fprintf(os.Stderr, "ã‚¨ãƒ©ãƒ¼: å‹å®šç¾©ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: %v\n", err)
		os.Exit(1)
	}

	// ã‚¯ã‚¨ãƒªæ§‹é€ ä½“ã‚’ç”Ÿæˆ
	queryPath := filepath.Join(outputDir, "queries.go")
	fmt.Printf("ğŸ“ ã‚¯ã‚¨ãƒªæ§‹é€ ä½“ã‚’ç”Ÿæˆä¸­: %s\n", queryPath)
	if err := generateQueries(queryPath); err != nil {
		fmt.Fprintf(os.Stderr, "ã‚¨ãƒ©ãƒ¼: ã‚¯ã‚¨ãƒªæ§‹é€ ä½“ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("âœ… ã‚³ãƒ¼ãƒ‰ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸï¼")
}

// parseSchema GraphQLã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã—ã¦å‹å®šç¾©ã‚’æŠ½å‡º
func parseSchema(path string) (map[string]TypeDefinition, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ: %w", err)
	}
	defer file.Close()

	types := make(map[string]TypeDefinition)
	scanner := bufio.NewScanner(file)

	var currentType *TypeDefinition
	var inTypeDefinition bool

	typePattern := regexp.MustCompile(`^type\s+(\w+)\s*(implements\s+[\w\s&]+)?\s*\{`)
	fieldPattern := regexp.MustCompile(`^\s+(\w+)\s*:\s*([!\w\[\]\(\),&\s]+)`)

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// å‹å®šç¾©ã®é–‹å§‹ã‚’æ¤œå‡º
		if matches := typePattern.FindStringSubmatch(line); matches != nil {
			typeName := matches[1]
			if contains(typesToExtract, typeName) {
				currentType = &TypeDefinition{
					Name:   typeName,
					Fields: []FieldDefinition{},
				}
				types[typeName] = *currentType
				inTypeDefinition = true
				continue
			}
		}

		// å‹å®šç¾©ã®ä¸­ã«ã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½å‡º
		if inTypeDefinition && currentType != nil {
			if trimmed == "}" || trimmed == "}" {
				inTypeDefinition = false
				currentType = nil
				continue
			}

			if matches := fieldPattern.FindStringSubmatch(line); matches != nil {
				fieldName := matches[1]
				fieldType := strings.TrimSpace(matches[2])
				required := strings.HasSuffix(fieldType, "!")

				field := FieldDefinition{
					Name:     fieldName,
					Type:     fieldType,
					Required: required,
				}
				// currentTypeã‚’æ›´æ–°ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€mapã‹ã‚‰å–å¾—ã—ã¦æ›´æ–°
				if t, ok := types[currentType.Name]; ok {
					t.Fields = append(t.Fields, field)
					types[currentType.Name] = t
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: %w", err)
	}

	return types, nil
}

// contains ã‚¹ãƒ©ã‚¤ã‚¹ã«è¦ç´ ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// generateTypes å‹å®šç¾©ã®Goã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
func generateTypes(outputPath string, types map[string]TypeDefinition) error {
	tmpl := `// Code generated by tools/generate-github-types/main.go. DO NOT EDIT.

package generated

import (
	"time"
)

{{range .Types}}
// {{.Name}} {{.Description}}
type {{.Name}} struct {
{{range .Fields}}
	{{.Name | title}} {{.Type | goType}} ` + "`" + `graphql:"{{.Name}}"` + "`" + `{{end}}
}
{{end}}
`

	funcMap := template.FuncMap{
		"title": strings.Title,
		"goType": func(gqlType string) string {
			return convertGraphQLTypeToGo(gqlType)
		},
	}

	t := template.Must(template.New("types").Funcs(funcMap).Parse(tmpl))

	data := struct {
		Types []TypeDefinition
	}{
		Types: extractTypesInOrder(types),
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸ: %w", err)
	}
	defer file.Close()

	return t.Execute(file, data)
}

// generateQueries ã‚¯ã‚¨ãƒªæ§‹é€ ä½“ã®Goã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
func generateQueries(outputPath string) error {
	tmpl := `// Code generated by tools/generate-github-types/main.go. DO NOT EDIT.

package generated

// ViewerQuery èªè¨¼ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã‚¯ã‚¨ãƒª
type ViewerQuery struct {
	Viewer User ` + "`" + `graphql:"viewer"` + "`" + `
}

// ReposQueryVariables ãƒªãƒã‚¸ãƒˆãƒªã‚¯ã‚¨ãƒªã®å¤‰æ•°
type ReposQueryVariables struct {
	Login  string  ` + "`" + `json:"login"` + "`" + `
	IsFork *bool   ` + "`" + `json:"isFork,omitempty"` + "`" + `
	First  *int    ` + "`" + `json:"first,omitempty"` + "`" + `
	After  *string ` + "`" + `json:"after,omitempty"` + "`" + `
}

// ReposQuery ãƒªãƒã‚¸ãƒˆãƒªæƒ…å ±ã‚’å–å¾—ã™ã‚‹ã‚¯ã‚¨ãƒª
type ReposQuery struct {
	User struct {
		Repositories struct {
			Nodes    []Repository ` + "`" + `graphql:"nodes"` + "`" + `
			PageInfo PageInfo     ` + "`" + `graphql:"pageInfo"` + "`" + `
		} ` + "`" + `graphql:"repositories(isFork: $isFork, first: $first, after: $after, ownerAffiliations: OWNER)"` + "`" + `
	} ` + "`" + `graphql:"user(login: $login)"` + "`" + `
}
`

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸ: %w", err)
	}
	defer file.Close()

	_, err = file.WriteString(tmpl)
	return err
}

// convertGraphQLTypeToGo GraphQLå‹ã‚’Goå‹ã«å¤‰æ›
func convertGraphQLTypeToGo(gqlType string) string {
	gqlType = strings.TrimSpace(gqlType)
	required := strings.HasSuffix(gqlType, "!")
	if required {
		gqlType = strings.TrimSuffix(gqlType, "!")
	}

	// é…åˆ—å‹ã®å‡¦ç†
	if strings.HasPrefix(gqlType, "[") && strings.HasSuffix(gqlType, "]") {
		inner := strings.TrimPrefix(strings.TrimSuffix(gqlType, "]"), "[")
		goType := convertGraphQLTypeToGo(inner)
		result := "[]" + goType
		if !required {
			result = "*" + result
		}
		return result
	}

	// åŸºæœ¬çš„ãªå‹ã®ãƒãƒƒãƒ”ãƒ³ã‚°
	switch gqlType {
	case "String":
		if required {
			return "string"
		}
		return "*string"
	case "Int":
		if required {
			return "int"
		}
		return "*int"
	case "Float":
		if required {
			return "float64"
		}
		return "*float64"
	case "Boolean":
		if required {
			return "bool"
		}
		return "*bool"
	case "ID":
		if required {
			return "string"
		}
		return "*string"
	case "DateTime", "GitTimestamp":
		if required {
			return "time.Time"
		}
		return "*time.Time"
	case "URI":
		if required {
			return "string"
		}
		return "*string"
	default:
		// ã‚«ã‚¹ã‚¿ãƒ å‹ï¼ˆUser, Repositoryãªã©ï¼‰
		if required {
			return gqlType
		}
		return "*" + gqlType
	}
}

// extractTypesInOrder å‹ã‚’é †åºã‚ˆãæŠ½å‡º
func extractTypesInOrder(types map[string]TypeDefinition) []TypeDefinition {
	var result []TypeDefinition
	for _, typeName := range typesToExtract {
		if t, ok := types[typeName]; ok {
			result = append(result, t)
		}
	}
	return result
}
